Download Link: https://assignmentchef.com/product/solved-24677-project-5
<br>
In the previous projects, we have learned how to apply modern control techniques to an Unmanned Ground Vehicle (UGV). In this project, we will step up the difficulty and investigate how to control an Unmanned Aerial Vehicle (UAV).

Quadrotor drones has risen in popularity in recent year for a variety of uses, such as aerial photography for topology and agriculture, search and rescue missions, and product delivery. Ever-increasing demands on safety and performance have necessitated the development of more and more sophisticate flight control systems. Unlike ground vehicle, these flying vehicles could be inherently unstable due to many sources of uncertainty such as actuator degradation, external disturbances, and complex unmodeled dynamics (blade flapping and asymmetric angular speed of propellers), which often results in a crash.

In this project, we will make use of adaptive control theory to augment a LQR-based

MPC controller and test its effectiveness in the event of a single quadrotor motor of a DJI<sup>TM </sup>Mavic 2 Pro experience a 50% pr higher percent lost of thrust during hovering. As before, the experiment will be performed in the Webots simulator.

This project is the last part of the course project series:

P5         (a) Design a baseline LQR controller to fly the quadrotor without any motor failure.

(b) Design a MRAC to fly the quadrotor with 50% lost of thrust in one motor.

<h1>1             Model</h1>

We will use a popular model of the quadrotor as the control model. As shown in Figure 1, the inertial frame is fixed to the ground. The roll axis of the quadrotor is pointing forward w.r.t. to the drone body. The pitch axis is pointing to the left. The yaw axis is pointing upwards. We will present the simplified nonlinear dynamics model and linearized dynamics model in Section 2.1 and 2.2. The model parameters are defined in Table 1.

Figure 1: Coordinate systems

<h2>1.1           Nonlinear dynamics</h2>

The dynamics of quadrotor helicopters have been studied in detail by many researchers. Assuming the vehicle as a rigid-body and operating at low speed, the dynamics are given by:

where <em>x,y, </em>and <em>z </em>are the positions of the center of mass in the inertial frame; <em>φ,θ, </em>and <em>ψ </em>are the Euler angles which describe the orientation of the body-fixed frame with respect to the inertial frame; <em>m,I<sub>x</sub>,I<sub>y</sub>, </em>and <em>I<sub>z </sub></em>are the mass and moments of inertial of the quadrotor respectively; and <em>J<sub>R </sub></em>and Ω<em><sub>R </sub></em>are the moment of inertia and angular velocity(i.e. rotor speed) of the propeller blades. <em>U</em><sub>1 </sub>is the collective thrust, <em>U</em><sub>2</sub><em>,U</em><sub>3</sub><em>, </em>and <em>U</em><sub>4 </sub>are the roll, pitch and yaw torques generated by the four propellers.

<h2>1.2           Linear dynamics</h2>

Since the quadrotor typically operates very near the hover position, we can linearize the system by making small angle approximations, neglecting higher order terms and letting <em>U</em><sub>1 </sub>= <em>mg </em>+ ∆<em>U</em><sub>1</sub>, which will result in the linear dynamics:

Although this linear system seems a bit over simplified than the nonlinear dynamics, it still captures the dominant features of the quadrotor, and is sufficient near the hover position. As expected, the roll, pitch and yaw input command moments about their respective axes and the collective input commands acceleration in the positive <em>z</em>-direction. Accelerations in the <em>x</em>– and <em>y</em>-directions are achieved primarily through vectoring the collective thrust.

For the purposes of the controller design, we will use the linearized dynamics.

<h2>1.3           Physical Parameters</h2>

All relevant physical parameters are listed here. The definitions of <em>d</em><sub>1<em>x</em></sub>, <em>d</em><sub>2<em>x</em></sub>, <em>d</em><sub>1<em>y </em></sub>and <em>d</em><sub>1<em>y </em></sub>are showd in Figure 2.

Figure 2: Definition of <em>d</em><sub>1<em>x</em></sub>, <em>d</em><sub>2<em>x</em></sub>, <em>d</em><sub>1<em>y </em></sub>and <em>d</em><sub>1<em>y</em></sub>

Table 1: Model parameters.

<table width="600">

 <tbody>

  <tr>

   <td width="72">Name</td>

   <td width="278">Description</td>

   <td width="66">Unit</td>

   <td width="183">Value</td>

  </tr>

  <tr>

   <td width="72">(<em>X,Y,Z</em>)</td>

   <td width="278">Vehicle’s        coordinates    in         the           world frame</td>

   <td width="66">m</td>

   <td width="183">State</td>

  </tr>

  <tr>

   <td width="72">(<em>x,</em>˙ <em>y,</em>˙ <em>z</em>˙)</td>

   <td width="278">Vehicle’s velocity along the direction of vehicle frame</td>

   <td width="66">m/s</td>

   <td width="183">State</td>

  </tr>

  <tr>

   <td width="72">(<em>φ,θ,ψ</em>)</td>

   <td width="278">Body row, pitch, yaw angle</td>

   <td width="66">rad</td>

   <td width="183">State</td>

  </tr>

  <tr>

   <td width="72"></td>

   <td width="278">Body row, pitch, yaw angle rate</td>

   <td width="66">rad/s</td>

   <td width="183">State</td>

  </tr>

  <tr>

   <td width="72"> </td>

   <td width="278">Vehicle mass</td>

   <td width="66">kg</td>

   <td width="183">0.4</td>

  </tr>

  <tr>

   <td width="72"><em>d</em>1<em>x</em></td>

   <td width="278">Length in x-axis from front rotors to the center of mass</td>

   <td width="66">m</td>

   <td width="183">0.1122</td>

  </tr>

  <tr>

   <td width="72"><em>d</em>2<em>x</em></td>

   <td width="278">Length in x-axis from rear rotors to the center of mass</td>

   <td width="66">m</td>

   <td width="183">0.1171</td>

  </tr>

  <tr>

   <td width="72"><em>d</em>1<em>y</em></td>

   <td width="278">Length in y-axis from front rotors to the center of mass</td>

   <td width="66">m</td>

   <td width="183">0.1515</td>

  </tr>

  <tr>

   <td width="72"><em>d</em>2<em>y</em></td>

   <td width="278">Length in x-axis from rear rotors to the center of mass</td>

   <td width="66">m</td>

   <td width="183">0.1280</td>

  </tr>

  <tr>

   <td width="72"><em>I<sub>x</sub></em></td>

   <td width="278">Moment of inertia around x-axis</td>

   <td width="66">kg mˆ2</td>

   <td width="183">0.000913855</td>

  </tr>

  <tr>

   <td width="72"><em>I<sub>y</sub></em></td>

   <td width="278">Moment of inertia around y-axis</td>

   <td width="66">kg mˆ2</td>

   <td width="183">0.00236242</td>

  </tr>

  <tr>

   <td width="72"><em>I<sub>z</sub></em></td>

   <td width="278">Moment of inertia around z-aixs</td>

   <td width="66">kg mˆ2</td>

   <td width="183">0.00279965</td>

  </tr>

  <tr>

   <td width="72"><em>c<sub>t</sub></em></td>

   <td width="278">thrust coefficient</td>

   <td width="66">N</td>

   <td width="183">0.00026</td>

  </tr>

  <tr>

   <td width="72"><em>c<sub>τ</sub></em></td>

   <td width="278">torque coefficient</td>

   <td width="66">kg mˆ2</td>

   <td width="183">5.2e-06</td>

  </tr>

  <tr>

   <td width="72">∆<em>T</em></td>

   <td width="278">Simulation timestep</td>

   <td width="66">sec</td>

   <td width="183">0.01</td>

  </tr>

 </tbody>

</table>

<h1>2             Controllers</h1>

In order to access the effectiveness of adaptive controller in the presence of model uncertainty, We will use a LQR controller as the baseline controller for comparison.

<h2>2.1           Problem statement</h2>

The primary function of the adaptive controller is to accommodate any uncertainties which may arise in the dynamics. We can write the equations of motion in section (2.2) along with these uncertainties as

<em>x</em>˙<em><sub>p </sub></em>= <em>A<sub>p</sub>x<sub>p </sub></em>+ <em>B<sub>p</sub></em>Λ<em>u                                                            </em>(1)

where <em>B<sub>p </sub></em>∈ <em>R<sup>n</sup></em><em><sup>p</sup></em><sup>×<em>m </em></sup>is constant and known, <em>A<sub>p </sub></em>∈ <em>R<sup>n</sup></em><em><sup>p</sup></em><sup>×<em>n</em></sup><em><sup>p </sup></em>is constant and unknown, <em>x<sub>p </sub></em>∈ <em>R<sup>n</sup></em><em><sup>p</sup></em>, <em>u </em>∈ <em>R<sup>m</sup></em>, Λ ∈ <em>R<sup>m</sup></em><sup>×<em>m </em></sup>is an unknown diagonal positive definite matrix. The state <em>x<sub>p </sub></em>= [<em>x,y,z,φ,θ,ψ,x,</em>˙ <em>y,</em>˙ <em>z,</em>˙ <em>φ,</em><sup>˙ </sup><em>θ,</em><sup>˙ </sup><em>ψ</em><sup>˙</sup>]. The control input <em>u </em>= [∆<em>U</em><sub>1</sub><em>,U</em><sub>2</sub><em>,U</em><sub>3</sub><em>,U</em><sub>4</sub>]. The goal is to track a reference command <em>r</em>(<em>t</em>) ∈ <em>R<sup>m </sup></em>in the presence of the unknown <em>A<sub>p</sub></em>, and Λ. We define the system output as

<em>y</em><em>p </em>= <em>C</em><em>px</em><em>p</em>

In the case of the quadrotor, the output states are <em>x</em>, <em>y</em>, <em>z</em>, <em>ψ </em>and <em>m </em>= 4. The output tracking error is then given by

<em>e<sub>y </sub></em>= <em>y<sub>p </sub></em>− <em>r</em>

Augmenting (1) with the integrated output tracking error,

Z <em>e</em><em>yI </em>=       <em>e</em><em>ydt,     e</em>˙<em>yI </em>= <em>e</em><em>y</em>

leads to the extended open loop dynamics

<em>x</em>˙<em><sub>t </sub></em>= <em>A<sub>t</sub>x<sub>t </sub></em>+ <em>B<sub>t</sub></em>Λ<em>u </em>+ <em>B<sub>c</sub>r                                                        </em>(2)

where is the extended system state vector.      The extended open-loop

system matrices are given by

and the extended system output

<em>y</em><em>t </em>= [<em>C</em><em>p               </em>0<em>m</em>×<em>m</em>]<em>x</em><em>t </em>= <em>C</em><em>tx</em><em>t</em>

<h2>2.2           Baseline LQR Controller</h2>

A baseline LQR controller <em>u</em><em>bl </em>= <em>K</em><em>blx</em><em>t</em>

can be designed for the system in (2) in the case where there is no model discrepancy, i.e., Λ = <em>I<sub>m</sub></em><sub>×<em>m </em></sub>and <em>A </em>is taken at some nominal value <em>A</em><sup>¯ </sup>where actually <em>A </em>= <em>A</em><sup>¯ </sup>+ <em>A</em><sup>∗ </sup>and <em>A</em><sup>∗ </sup>contains all the unmodeled terms. The feedback gains <em>K<sub>bl </sub></em>can be selected using standard LQR design techniques.

<h2>2.3           Model Reference Adaptive Controller</h2>

The reference model used by MRAC is the closed loop system given by (2), again in the case of no uncertainty, along with the control input in Section 3.2

(3)

We can design an adaptive control input

(4)

such that the resulted system (5) can track the reference model in (3)

(5) The canonical adaptive law is given by

ˆ<sup>˙ </sup>= −Γ<em>ωe<sup>T</sup>PB<sub>t</sub></em>

<em>θ</em>

where Γ is a diagonal positive definite matrix of adaptive gains, <em>e </em>= <em>x</em>−<em>x<sub>m </sub></em>is the model tracking error, and <em>P </em>is the unique symmetric positive definite solution of the Lyapunov equation

where <em>Q </em>is also symmetric positive definite.

The augmented structure of the adaptive controller implies that in the nominal case, i.e., the case with no parameter uncertainty, the overall system is equivalent to the baseline control. However, when failures or other uncertainties arise, the adaptive controller works to assist the baseline controller in maintaining stability and performance. With the Lyapunov function candidate given by

<em>V </em>= <em>e<sup>T</sup>Pe </em>+ <em>Tr</em>(<em>θ</em><sup>˜<em>T</em></sup>Γ<sup>−1</sup><em>θ</em><sup>˜</sup>)

where <em>θ</em><sup>˜ </sup>= <em>θ</em><sup>ˆ</sup>−<em>θ </em>is the parameter estimation error, it can be shown [7] that the derivative of the Lyapunov function candidate is given by

<em>V</em><sup>˙ </sup>= −<em>e<sup>T</sup>Pe </em>≤ 0

The system is globally asymptotically stable and the tracking error asymptotically converges to 0, that is

lim <em>e</em>(<em>t</em>) = 0 <em>t</em>→∞

<h1>3             P5: Problems</h1>

<strong>Exercise 1. (50 points) </strong>Design a discrete-time infinite horizon LQR controller for the quadrotor to track the command when there is no motor failure. You should complete the code in <strong>lqr controller.py</strong>. Attach the plot generated by completing 60s simulation and report the error generated at the end of simulation in your write-up. If your error is lower than <em>lower bar</em>, you will receive full score. Otherwise your score will be calculated as (<em>upper bar</em>−<em>your </em><em>error</em>)<em>/</em>(<em>upper bar</em>−<em>lower </em><em>bar</em>)∗50 where <em>lower bar </em>is 0<em>.</em>5 and <em>upper bar </em>is 0<em>.</em>8.

<strong>You are strongly recommended to go through the code base provided. </strong>Some hints that may be useful: • Make sure to discretize your continuous state-space system with the provided timestep (∆<em>T</em>) prior to solving the ARE.

<ul>

 <li>Using LQR requires designing the <em>Q </em>and <em>R </em>matrices. <em>Q </em>penalizes state variables, while <em>R </em>penalizes control input. Try to think about what form your <em>Q </em>and <em>R </em>matrices should take for good performance.</li>

 <li>For <em>Q</em>, large values will restrict changes to the respective states, while smaller values will allow the states to easily change.</li>

 <li>Similarly, in <em>R</em>, larger values will restrict control input, while smaller values will allow the control input to vary more.</li>

 <li>Empirically, it is reasonable to set the entries in the Q and R to be</li>

</ul>

1

(<strong>max value of the corresponding state/input</strong>)<sup>2</sup>

in order to normalize the penalty weights.

<strong>Exercise 2.</strong>

<ol>

 <li><strong>(30 points) </strong>Design a MRAC to fly the quadrotor with 50% lost of thrust in one motor. You should complete the code in <strong>adaptive controller.py</strong>. Attach the plot generated by completing 60s simulation and report your percentage lost of thrust. Please see Appendix 1 for details on how we simulate motor failure. If your LQR and MRAC controller can stablize the system with 50% lost of thrust, you will get full score. Otherwise, you will get (<em>your percentage lost of thrust</em>)<em>/</em>50 ∗ 30 points.</li>

 <li><strong>(20 points) </strong>Find a percentage lost of thrust such that LQR fails but MRAC works. Report the percentage lost of thrust and attach the plot.</li>

</ol>

In order to change the percentage lost of thrust, go to <strong>AdaptiveController.py </strong>(not <strong>adaptive controller.py</strong>) and change the value of the variable <strong>lossOfThust </strong>to your percentage lost of thrust. If you want to change which controller to use, edit line 28 of <strong>AdaptiveController.py </strong>to either customController = AdaptiveController(driver, lossOfThust) or

customController = LQRController(driver, lossOfThust)

Some hints that may be useful:

<ul>

 <li>Initialize the gain matrix to your LQR gain. It will help you stabilize the system.</li>

</ul>

<h1>4             Appendix</h1>

<h2>4.1           Conversion from control input to rotor speed</h2>

For our quadrotor model in webots, the propeller turns the motor angular velocity into a thrust and a (resistant) torque. The resultant thrust <em>T </em>of each motor is given by the product of thrust constants <em>c<sub>t </sub></em>and the square of the angular velocity, where as the resultant torque <em>τ </em>is given by the product of torque coefficient <em>c<sub>τ </sub></em>and the the square of the angular velocity.

<ul>

 <li>= <em>c<sub>t</sub>ω</em><sup>2 </sup><em>τ </em>= <em>c<sub>τ</sub>ω</em><sup>2</sup></li>

</ul>

The control input <em>U</em><sub>1 </sub>is simply the sum of the thrust of all propellers, and the row, pitch torque <em>U</em><sub>2</sub><em>,U</em><sub>3 </sub>are the sum of torque generated by the opposite propellers around certain axes. The yaw torque <em>U</em><sub>4 </sub>is the sum of the torque generated by all the propellers around the z-aixs.

Hence, we can write the conversion matrix <em>H </em>from rotor speed Ω = [ to <em>U </em>= [<em>U</em><sub>1 </sub><em>U</em><sub>2 </sub><em>U</em><sub>3 </sub><em>U</em><sub>4</sub>]<em><sup>T </sup></em>as:

Inversely, to get the desired motor speeds from control input, we use the inverse of <em>H </em>matrix.

<ul>

 <li>= <em>H</em>Ω → Ω = <em>H</em><sup>−1</sup><em>U</em>.</li>

</ul>

<h2>4.2           Simulating Actuator failure</h2>

To simulate around 50% lost of thrust in motor number 1, the control input to be used for the simulation <em>U<sub>fail </sub></em>is given by:

<table width="216">

 <tbody>

  <tr>

   <td width="113"><sup></sup>0<em>.</em>7<em>U</em><em>fail </em>= <em>H </em> 000</td>

   <td width="21">0100</td>

   <td width="21">0 010</td>

   <td width="61"></td>

  </tr>

 </tbody>

</table>

<h1>5             Reference</h1>

[1] Dydek, Zachary T., Anuradha M. Annaswamy, and Eugene Lavretsky. ”Adaptive control of quadrotor UAVs: A design trade study with flight evaluations.” IEEE Transactions on control systems technology 21.4 (2012): 1400-1406.